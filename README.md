# PTLab_4

```python
import numpy as np
N = 85
M = np.diag(1 + 2*np.arange(N)) + 2 * np.ones((N, N))
print(M)
```

С помощью `np.arange(N)` создается одномерный массив, содержащий арифметическую прогрессию от 0 до N-1. N у нас равно 85. Далее `2 * np.arange(N)` - каждый элемент полученного массива умножается на 2. К каждому элементу массива добавляется 1. 
В `2 * np.ones((N, N))` создается матрица размера 85x85, заполненная двойками. Со всем этим создается диагональная матрица с элементами из полученного массива на ее главной диагонали. все элементы вне главной диагонали=0. 
В данном случае это матрица размера 85x85 с элементами `[3, 5, ..., 167, 169, 171]` на ее главной диагонали.



```python
template1 = np.array([4, 4, 5])
template2 = np.array([4, 7, 4, 7, 4, 7])
pattern1 = np.tile(template1, N // len(template1))
pattern2 = np.tile(template2, N // len(template2))
N = np.vstack([pattern1, pattern2] * (N // 2))
print(N)
```
Темплейты идут как шаблоны для задания массива. С использованием функции `np.tile` создается новый массив `pattern1`, повторяя `template1` столько раз, сколько помещается целых копий в `N // len(template1)`. Аналогично создается новый массив `pattern2`.
Потом Создается двумерный массив `N`, вертикально стекая массивы `pattern1` и `pattern2`. Выражение `[pattern1, pattern2] * (N // 2)` создает список, в котором `pattern1` и `pattern2` повторяются `(N // 2)` раз, и затем они вертикально стекаются.


```python
mean = 2
std_dev = 4
p_i_values = np.random.normal(mean, std_dev, 84)
p = 1 + p_i_values
```

`mean = 2` - математическое ожидание для нормального распределения. Задается стандартное отклонение `std_dev = 4` для нормального распределения.
Генерируется массив `p_i_values`, содержащий 84 случайных числа, распределенных нормально с указанным средним значением `mean` и стандартным отклонением `std_dev`.
Создается новый массив `p`, который получается путем прибавления 1 к каждому элементу массива `p_i_values`.
в результате выполнения будет массив `p`, который представляет собой исходные случайные значения, сгенерированные из нормального распределения, и увеличенные на 1.


```python
mean_1 = 24
mean_2 = 71
std_dev = 4
N_1 = np.random.normal(mean_1, std_dev, 84)
N_2 = np.random.normal(mean_2, std_dev, 84)
q_T = np.multiply(N_1, N_2)
```

Задается математическое ожидание для первого и второго нормального распределения. Задается стандартное отклонение `std_dev = 4` для обоих нормальных распределений.
Генерируется массив `N_1`, содержащий 84 случайных числа, распределенных нормально с указанным средним значением `mean_1` и стандартным отклонением `std_dev`. Аналогично `N_2`.
`q_T` представляет собой поэлементное произведение соответствующих элементов массивов `N_1` и `N_2`, полученных из нормальных распределений с разными средними значениями.

```python
q = np.random.normal(0, 1, 84)
q_2 = np.square(q)
```

Генерируем массив `q` из 84 случайных чисел, распределенных нормально с средним значением 0 и стандартным отклонением 1.

2. `np.square(q)`: Создает новый массив `q_2`, который получается путем поэлементного возведения в квадрат элементов массива `q`.
`q` содержит случайные числа из стандартного нормального распределения а `q_2` квадраты соответствующих элементов `q`.

```python
k = np.argmax(q_2)
```

Берётся максимальное значение

```python
f = 4 * np.random.normal(k, 59)
```
Генерируется случайное число, выбранное из нормального распределения с параметрами `k` в качестве среднего значения и 59 в качестве стандартного отклонения. 
Здесь `k` - это индекс, который был получен предыдущим кодом `np.argmax(q_2)` и представляет собой индекс элемента с максимальным значением в `q_2`.
элементы `f` получаются умножением случайных чисел из нормального распределения на 4, где параметр `k` используется как среднее значение для генерации этих случайных чисел.

```python
product_matrix = 7e-6 * M[:, 13:28] * p[12:27]
product_result = np.prod(product_matrix, axis=1)
sum_result = np.sum(product_result[23:70]) 
result = sum_result
```
матрица `product_matrix` получается умножением каждого элемента подматрицы `M` (все строки, начиная с 13-й и заканчивая 27-й включительно) на соответствующий элемент вектора `p[12:27]`, и затем умножением этого результата на `7e-6`.
Вычисляется произведение элементов по каждой строке матрицы `product_matrix`. Результат представляет собой одномерный массив `product_result`.
Вычисляется сумма элементов в диапазоне от 23 до 69 (включительно) массива `product_result`.
`result = sum_result`: Значение `result` устанавливается равным значению `sum_result`.
`result` представляет собой сумму произведений элементов `product_matrix` по каждой строке в определенном диапазоне строк (от 23-й до 69-й строки включительно).

```python

```

```python

```

```python

```

```python

```

```python

```
